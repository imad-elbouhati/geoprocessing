{"version":3,"file":"greiner-hormann.leaflet.min.js","sources":["../src/vertex.js","../src/intersection.js","../src/polygon.js","../src/clip.leaflet.js","../src/leaflet.js"],"sourcesContent":["export default class Vertex {\n\n  /**\n   * Vertex representation\n   *\n   * @param {Number|Array.<Number>} x\n   * @param {Number=}               y\n   */\n  constructor (x, y) {\n    if (arguments.length === 1) {\n      // Coords\n      if (Array.isArray(x)) {\n        y = x[1];\n        x = x[0];\n      } else {\n        y = x.y;\n        x = x.x;\n      }\n    }\n\n    /**\n     * X coordinate\n     * @type {Number}\n     */\n    this.x = x;\n\n    /**\n     * Y coordinate\n     * @type {Number}\n     */\n    this.y = y;\n\n    /**\n     * Next node\n     * @type {Vertex}\n     */\n    this.next = null;\n\n    /**\n     * Previous vertex\n     * @type {Vertex}\n     */\n    this.prev = null;\n\n    /**\n     * Corresponding intersection in other polygon\n     */\n    this._corresponding = null;\n\n    /**\n     * Distance from previous\n     */\n    this._distance = 0.0;\n\n    /**\n     * Entry/exit point in another polygon\n     * @type {Boolean}\n     */\n    this._isEntry = true;\n\n    /**\n     * Intersection vertex flag\n     * @type {Boolean}\n     */\n    this._isIntersection = false;\n\n    /**\n     * Loop check\n     * @type {Boolean}\n     */\n    this._visited = false;\n  }\n\n\n  /**\n   * Creates intersection vertex\n   * @param  {Number} x\n   * @param  {Number} y\n   * @param  {Number} distance\n   * @return {Vertex}\n   */\n  static createIntersection (x, y, distance) {\n    const vertex = new Vertex(x, y);\n    vertex._distance = distance;\n    vertex._isIntersection = true;\n    vertex._isEntry = false;\n    return vertex;\n  }\n\n\n  /**\n   * Mark as visited\n   */\n  visit () {\n    this._visited = true;\n    if (this._corresponding !== null && !this._corresponding._visited) {\n        this._corresponding.visit();\n    }\n  }\n\n\n  /**\n   * Convenience\n   * @param  {Vertex}  v\n   * @return {Boolean}\n   */\n  equals (v) {\n    return this.x === v.x && this.y === v.y;\n  }\n\n\n  /**\n   * Check if vertex is inside a polygon by odd-even rule:\n   * If the number of intersections of a ray out of the point and polygon\n   * segments is odd - the point is inside.\n   * @param {Polygon} poly\n   * @return {Boolean}\n   */\n  isInside (poly) {\n    let oddNodes = false;\n    let vertex = poly.first;\n    let next = vertex.next;\n    const x = this.x;\n    const y = this.y;\n\n    do {\n      if ((vertex.y < y && next.y   >= y ||\n             next.y < y && vertex.y >= y) &&\n          (vertex.x <= x || next.x <= x)) {\n        oddNodes ^= (vertex.x + (y - vertex.y) /\n              (next.y - vertex.y) * (next.x - vertex.x) < x);\n      }\n\n      vertex = vertex.next;\n      next = vertex.next || poly.first;\n    } while (!vertex.equals(poly.first));\n\n    return oddNodes;\n  }\n}\n","export default class Intersection {\n\n\n  /**\n   * @param {Vertex} s1\n   * @param {Vertex} s2\n   * @param {Vertex} c1\n   * @param {Vertex} c2\n   */\n  constructor(s1, s2, c1, c2) {\n\n    /**\n     * @type {Number}\n     */\n    this.x = 0.0;\n\n    /**\n     * @type {Number}\n     */\n    this.y = 0.0;\n\n    /**\n     * @type {Number}\n     */\n    this.toSource = 0.0;\n\n    /**\n     * @type {Number}\n     */\n    this.toClip = 0.0;\n\n    const d = (c2.y - c1.y) * (s2.x - s1.x) - (c2.x - c1.x) * (s2.y - s1.y);\n\n    if (d === 0) return;\n\n    /**\n     * @type {Number}\n     */\n    this.toSource = ((c2.x - c1.x) * (s1.y - c1.y) - (c2.y - c1.y) * (s1.x - c1.x)) / d;\n\n    /**\n     * @type {Number}\n     */\n    this.toClip = ((s2.x - s1.x) * (s1.y - c1.y) - (s2.y - s1.y) * (s1.x - c1.x)) / d;\n\n    if (this.valid()) {\n        this.x = s1.x + this.toSource * (s2.x - s1.x);\n        this.y = s1.y + this.toSource * (s2.y - s1.y);\n    }\n  }\n\n\n  /**\n   * @return {Boolean}\n   */\n  valid () {\n      return (0 < this.toSource && this.toSource < 1) && (0 < this.toClip && this.toClip < 1);\n  }\n}\n","import Vertex from './vertex';\nimport Intersection from './intersection';\n\n\nexport default class Polygon {\n\n\n  /**\n   * Polygon representation\n   * @param {Array.<Array.<Number>>} p\n   * @param {Boolean=}               arrayVertices\n   */\n  constructor (p, arrayVertices) {\n\n    /**\n     * @type {Vertex}\n     */\n    this.first = null;\n\n    /**\n     * @type {Number}\n     */\n    this.vertices = 0;\n\n    /**\n     * @type {Vertex}\n     */\n    this._lastUnprocessed = null;\n\n    /**\n     * Whether to handle input and output as [x,y] or {x:x,y:y}\n     * @type {Boolean}\n     */\n    this._arrayVertices = (typeof arrayVertices === \"undefined\") ?\n        Array.isArray(p[0]) :\n        arrayVertices;\n\n    for (let i = 0, len = p.length; i < len; i++) {\n      this.addVertex(new Vertex(p[i]));\n    }\n  }\n\n\n  /**\n   * Add a vertex object to the polygon\n   * (vertex is added at the 'end' of the list')\n   *\n   * @param vertex\n   */\n  addVertex (vertex) {\n    if (this.first === null) {\n      this.first      = vertex;\n      this.first.next = vertex;\n      this.first.prev = vertex;\n    } else {\n      const next = this.first;\n      const prev = next.prev;\n\n      next.prev   = vertex;\n      vertex.next = next;\n      vertex.prev = prev;\n      prev.next   = vertex;\n    }\n    this.vertices++;\n  }\n\n\n  /**\n   * Inserts a vertex inbetween start and end\n   *\n   * @param {Vertex} vertex\n   * @param {Vertex} start\n   * @param {Vertex} end\n   */\n  insertVertex (vertex, start, end) {\n    let prev, curr = start;\n\n    while (!curr.equals(end) && curr._distance < vertex._distance) {\n      curr = curr.next;\n    }\n\n    vertex.next = curr;\n    prev        = curr.prev;\n\n    vertex.prev = prev;\n    prev.next   = vertex;\n    curr.prev   = vertex;\n\n    this.vertices++;\n  }\n\n  /**\n   * Get next non-intersection point\n   * @param  {Vertex} v\n   * @return {Vertex}\n   */\n  getNext (v) {\n    let c = v;\n    while (c._isIntersection) c = c.next;\n    return c;\n  }\n\n\n  /**\n   * Unvisited intersection\n   * @return {Vertex}\n   */\n  getFirstIntersect () {\n    let v = this._firstIntersect || this.first;\n\n    do {\n      if (v._isIntersection && !v._visited) break;\n\n      v = v.next;\n    } while (!v.equals(this.first));\n\n    this._firstIntersect = v;\n    return v;\n  }\n\n\n  /**\n   * Does the polygon have unvisited vertices\n   * @return {Boolean} [description]\n   */\n  hasUnprocessed () {\n    let v = this._lastUnprocessed || this.first;\n    do {\n      if (v._isIntersection && !v._visited) {\n        this._lastUnprocessed = v;\n        return true;\n      }\n\n      v = v.next;\n    } while (!v.equals(this.first));\n\n    this._lastUnprocessed = null;\n    return false;\n  }\n\n\n  /**\n   * The output depends on what you put in, arrays or objects\n   * @return {Array.<Array<Number>|Array.<Object>}\n   */\n  getPoints () {\n    const points = [];\n    let v = this.first;\n\n    if (this._arrayVertices) {\n      do {\n        points.push([v.x, v.y]);\n        v = v.next;\n      } while (v !== this.first);\n    } else {\n      do {\n        points.push({\n          x: v.x,\n          y: v.y\n        });\n        v = v.next;\n      } while (v !== this.first);\n    }\n\n    return points;\n  }\n\n  /**\n   * Clip polygon against another one.\n   * Result depends on algorithm direction:\n   *\n   * Intersection: forwards forwards\n   * Union:        backwars backwards\n   * Diff:         backwards forwards\n   *\n   * @param {Polygon} clip\n   * @param {Boolean} sourceForwards\n   * @param {Boolean} clipForwards\n   */\n  clip (clip, sourceForwards, clipForwards) {\n    let sourceVertex = this.first;\n    let clipVertex = clip.first;\n    let sourceInClip, clipInSource;\n\n    const isUnion        = !sourceForwards && !clipForwards;\n    const isIntersection = sourceForwards && clipForwards;\n    const isDiff         = !isUnion && !isIntersection;\n\n    // calculate and mark intersections\n    do {\n      if (!sourceVertex._isIntersection) {\n        do {\n          if (!clipVertex._isIntersection) {\n            const i = new Intersection(\n              sourceVertex,\n              this.getNext(sourceVertex.next),\n              clipVertex, clip.getNext(clipVertex.next)\n            );\n\n            if (i.valid()) {\n              const sourceIntersection = Vertex.createIntersection(i.x, i.y, i.toSource);\n              const clipIntersection   = Vertex.createIntersection(i.x, i.y, i.toClip);\n\n              sourceIntersection._corresponding = clipIntersection;\n              clipIntersection._corresponding   = sourceIntersection;\n\n              this.insertVertex(sourceIntersection, sourceVertex, this.getNext(sourceVertex.next));\n              clip.insertVertex(clipIntersection, clipVertex, clip.getNext(clipVertex.next));\n            }\n          }\n          clipVertex = clipVertex.next;\n        } while (!clipVertex.equals(clip.first));\n      }\n\n      sourceVertex = sourceVertex.next;\n    } while (!sourceVertex.equals(this.first));\n\n      // phase two - identify entry/exit points\n    sourceVertex = this.first;\n    clipVertex   = clip.first;\n\n    sourceInClip = sourceVertex.isInside(clip);\n    clipInSource = clipVertex.isInside(this);\n\n    sourceForwards ^= sourceInClip;\n    clipForwards ^= clipInSource;\n\n    do {\n      if (sourceVertex._isIntersection) {\n        sourceVertex._isEntry = sourceForwards;\n        sourceForwards = !sourceForwards;\n      }\n      sourceVertex = sourceVertex.next;\n    } while (!sourceVertex.equals(this.first));\n\n    do {\n      if (clipVertex._isIntersection) {\n        clipVertex._isEntry = clipForwards;\n        clipForwards = !clipForwards;\n      }\n      clipVertex = clipVertex.next;\n    } while (!clipVertex.equals(clip.first));\n\n    // phase three - construct a list of clipped polygons\n    let list = [];\n\n    while (this.hasUnprocessed()) {\n      let current = this.getFirstIntersect();\n      // keep format\n      const clipped = new Polygon([], this._arrayVertices);\n\n      clipped.addVertex(new Vertex(current.x, current.y));\n      do {\n        current.visit();\n        if (current._isEntry) {\n          do {\n            current = current.next;\n            clipped.addVertex(new Vertex(current.x, current.y));\n          } while (!current._isIntersection);\n\n        } else {\n          do {\n            current = current.prev;\n            clipped.addVertex(new Vertex(current.x, current.y));\n          } while (!current._isIntersection);\n        }\n        current = current._corresponding;\n      } while (!current._visited);\n\n      list.push(clipped.getPoints());\n    }\n\n    if (list.length === 0) {\n      if (isUnion) {\n        if (sourceInClip)      list.push(clip.getPoints());\n        else if (clipInSource) list.push(this.getPoints());\n        else                   list.push(this.getPoints(), clip.getPoints());\n      } else if (isIntersection) { // intersection\n        if (sourceInClip)      list.push(this.getPoints());\n        else if (clipInSource) list.push(clip.getPoints());\n      } else { // diff\n        if (sourceInClip)      list.push(clip.getPoints(), this.getPoints());\n        else if (clipInSource) list.push(this.getPoints(), clip.getPoints());\n        else                   list.push(this.getPoints());\n      }\n      if (list.length === 0) list = null;\n    }\n\n    return list;\n  }\n}\n","import Polygon from './polygon';\n\n/**\n * Clip driver\n * @param  {L.Polygon} polygonA\n * @param  {L.Polygon} polygonB\n * @param  {Boolean} sourceForwards\n * @param  {Boolean} clipForwards\n * @return {Array.<L.LatLng>|null}\n */\nexport default function (polygonA, polygonB, sourceForwards, clipForwards) {\n  let source = [], clip = [];\n\n  let latlngs = polygonA['_latlngs'][0];\n  for (let i = 0, len = latlngs.length; i < len; i++) {\n      source.push([latlngs[i]['lng'], latlngs[i]['lat']]);\n  }\n  latlngs = polygonB['_latlngs'][0];\n  for (let i = 0, len = latlngs.length; i < len; i++) {\n      clip.push([latlngs[i]['lng'], latlngs[i]['lat']]);\n  }\n\n  source = new Polygon(source),\n  clip = new Polygon(clip);\n\n  const result = source.clip(clip, sourceForwards, clipForwards);\n  if (result && result.length > 0) {\n    for (let i = 0, len = result.length; i < len; i++) {\n      result[i] = toLatLngs(result[i]);\n    }\n\n    if (result) {\n      if (result.length === 1) return result[0];\n      else                     return result;\n    } else return null;\n  } else return null;\n}\n\nfunction toLatLngs(poly) {\n  let result = poly;\n\n  if (result) {\n    if (result[0][0] === result[result.length - 1][0] &&\n        result[0][1] === result[result.length - 1][1]) {\n      result = result.slice(0, result.length - 1);\n    }\n\n    for (let i = 0, len = result.length; i < len; i++) {\n      result[i] = [result[i][1], result[i][0]];\n    }\n    return result;\n  } else {\n    return null;\n  }\n}\n","import boolean from './clip.leaflet';\n\n\n/**\n * @api\n * @param  {Array.<Array.<Number>|Array.<Object>} polygonA\n * @param  {Array.<Array.<Number>|Array.<Object>} polygonB\n * @return {Array.<Array.<Number>>|Array.<Array.<Object>|Null}\n */\nexport function union (polygonA, polygonB) {\n  return clip(polygonA, polygonB, false, false);\n}\n\n\n/**\n * @api\n * @param  {Array.<Array.<Number>|Array.<Object>} polygonA\n * @param  {Array.<Array.<Number>|Array.<Object>} polygonB\n * @return {Array.<Array.<Number>>|Array.<Array.<Object>>|Null}\n */\nexport function intersection (polygonA, polygonB) {\n  return clip(polygonA, polygonB, true, true);\n}\n\n\n/**\n * @api\n * @param  {Array.<Array.<Number>|Array.<Object>} polygonA\n * @param  {Array.<Array.<Number>|Array.<Object>} polygonB\n * @return {Array.<Array.<Number>>|Array.<Array.<Object>>|Null}\n */\nexport function diff (polygonA, polygonB) {\n  return clip(polygonA, polygonB, false, true);\n}\n\n\nexport const clip = boolean;\n"],"names":["Vertex","x","y","arguments","length","Array","isArray","this","next","prev","_corresponding","_distance","_isEntry","_isIntersection","_visited","createIntersection","distance","vertex","visit","equals","v","isInside","poly","let","oddNodes","first","Intersection","s1","s2","c1","c2","toSource","toClip","const","d","valid","Polygon","p","arrayVertices","vertices","_lastUnprocessed","_arrayVertices","i","len","addVertex","toLatLngs","result","slice","insertVertex","start","end","curr","getNext","c","getFirstIntersect","_firstIntersect","hasUnprocessed","getPoints","points","push","clip","sourceForwards","clipForwards","sourceInClip","clipInSource","sourceVertex","clipVertex","isUnion","isIntersection","sourceIntersection","clipIntersection","list","current","clipped","polygonA","polygonB","source","latlngs"],"mappings":"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"}